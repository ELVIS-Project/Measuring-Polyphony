# Perfection Filter

# Makes a table with different interval types based on output from 
# Rodan-client Vertical Interval Indexer. Works with any number of three-voice motets.

# Determines sonority based on first two intervals *or* the only one that exists.  
# A line that is all `'Rest'`s indicates a solo or silence and is classified as `None`.

# author: Emily Hopkins <emily.hopkins@mcgill.ca>

from enum import Enum
import fileinput


SPECIAL_IMPERFECTS = [
    ('-P4', '-m6'),
    ('-P4', '-M6'),
    ('P4', '-m3'),
    ('P4', '-M3')]

SPECIAL_DISSONANTS = [
    ('P4',),
    ('-P4',)]


class IntervalType(Enum):
    perfect = 1
    mixed = 2
    imperfect = 3
    dissonant = 4
    

def getlines():
    """
    Retrieves lines from csv file with file name and line number.
    """
    with fileinput.input() as f:
        for line in f:
            yield f.filename(), f.filelineno(), line


def intervalsfromlines(lines):
    """
    Takes a sequence of lines and offset numbers (output of getlines) and returns     
    all intervals on each line. Assumes that the lines come from CSV files generated by 
    Rodan-client, so skips over the first three lines that do not have intervals. 
    """
    for filename, filelineno, line in lines:
        if filelineno >= 4:
            intvs = line.strip().split(',')[1:]
            if any(x == 'Rest' for x in intvs):
                # This should always yield just one interval or no intervals.
                intv = tuple(x for x in intvs if x != 'Rest')
                assert len(intv) <= 1
                yield intv
            else:
                yield tuple(sorted(intvs[:2]))


def intervaltype(intv):
    """
    Defines interval types after Fuller (1986).
    """
    if len(intv) == 0:
        return None
    if intv in SPECIAL_DISSONANTS:
        return IntervalType.dissonant
    if intv in SPECIAL_IMPERFECTS:
        return IntervalType.imperfect
    for x in ['d', 'A', '2', '7', '4']:
        if any (x in y for y in intv):
            return IntervalType.dissonant
    if all('P' in x for x in intv):
        return IntervalType.perfect
    if any('P' in x for x in intv):
        return IntervalType.mixed
    for x in ['m3', 'M3', 'm6', 'M6']:
        if any(x in y for y in intv):
            return IntervalType.imperfect
    assert False

#Makes a table

table = {}                
for intv in intervalsfromlines(getlines()):
    it = intervaltype(intv)
    # print(intv, it)
    table.setdefault(it, 0)
    table[it] += 1
for k, v in sorted(table.items(), key=lambda x: x[1], reverse=True):
    print(k, v)
